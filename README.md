# Goo Data Model
The Goo Data Model is a data representation designed to contain all the data needed for a game or an app running on the Goo Engine. The data format is used internally in Goo Create, but is intended to work just as well in published apps or apps developed outside Goo Create. 

## Data Objects
An object is defined as the smallest potentially reusable piece of information. Each object has a globally unique key on the format "keystring.objectType".

There are currently two data types, JSON and Binary.

### JSON Objects
JSON objects are used for storing mutable data. The keystring for a JSON object is generated by a random string generator (TBD) and the objectType is goo-specific. 

#### Dependencies
A JSON object hold references to all its dependencies, both JSON and Binary. A dependency is an object that is needed for the parent object to be useful in its own right. E.g. a material needs its textures, which need their image files, otherwise the material cannot be displayed. An entity needs its child entities (a house is not a house without its roof) but it does not necessarily need its parent node. 

All dependencies are referenced by JSON keys ending in "ref" or "refs" (case insensitive). In the singular case, the value is simply the key of the dependency. In the plural case, the value is a Set, looking like this: 
  
  soundRefs: {
    listId: dependencyId
  } 

where listId is any locally unique string.

#### Access Control
A JSON object contains its own access control list: 

  ...
  owner: "[userId]",
  public: true/false,
  editors: {
    "[listId]": "[userId]",
    "[listId]": "[userId]"
  },
  viewers: {
    "[listId]": "[userId]",
    "[listId]": "[userId]"
  }

determining who can view and edit the object. This information is only used inside create, and could potentially be stripped on export to save size.  

### Binary objects

Binary objects are immutable, they can only be created and deleted. To e.g. change the image file for a texture, you create a new binary image resource and redirect the dependency reference in the texture JSON file to point to the new image. 

The object key for a binary file is a hash of the file content, salted with a user specific key (exact algorithm tbd). The hashing enables caching content (since it's immutable, we can cache forever), while the user-unique salt prevents intentional cache collisions. 

#### Access Control

Binary objects have a simpler access control list, since they cannot be edited:  

  public: true/false,
  viewers: {
    "[listId]": "[userId]",
    "[listId]": "[userId]"
  }

In Create, this data is stored in Riak's usermeta object for the binary. Outside Create this information is useless, so it will not be exported. 


### Merge-safe
...


 - Merge-safe (bitsquid)
  - No arrays (objects with sort values)
 
 - Dependencies
  - It must be possible to somehow get all the dependencies of a given object
   - Research (ask Basho)
    - Drivers: 
     - Performance
     - Robustness

   ? Manual indices (libraryRefs)
   ? Link walking
   ? Map reduce

  - All objects should reference their direct dependencies
   - Entities should reference their children, not their parent (parent is not a dependency)

  - All refs keys in the JSON should be easily identifiable
   ? End with Ref (single ref) or Refs (array-like of refs)
   - Binaries too (no more url)
 
 - Prefabs, selective override
  - When I use an object in my scene, a minimal linked object is created: 
  {
    id: "[localHouseID].entity",
    sourceRef: "[originalHouseID].entity"
  }
  where [localHouseID] and [originalHouseID] are GUIDs
  When the editor loads [localHousID], it reads originalHouseID and merges the two files
  before the data is loaded into the engine. This merge is done in the engine loaders/handlers. 

  I change the position of my house, and voila!
  {
    id: "[localHouseID].entity",
    sourceRef: "[originalHouseID].entity",
    ...
    transform: [x,x,x]
  }

  When loading a bundle, the dependency walker must load originalHouse if localHouse is in my scene, 
  hence the key is sourceRef.

  I can manually sever the link in the editor. The data from originalHouse will be copied to localHouse, 
  but future changes to originalHouse will not be reflected in localHouse. 

  If my level designer team mate wants to use my house in a level, he can insert it in his scene. This 
  will create a new object newLocalHouse with a link to my localHouse. Both my changes and changes to 
  originalHouse will be reflected in newLocalHouse. 

  If I want to sell/share my new improved localHouse on the asset market, all links are severed. Assets
  in the global asset library cannot have links. 

  Assets in the asset library are "immutable". Publishing local assets to an asset library copies
  the local asset, with dependencies, severs all the links and creates a version of the asset in the 
  asset library. If it's published anew, a new version of the same asset is created. Users can 
  potentially subscribe to new versions of originalHouse, and get notifications or similar. 

 - Merging new converted fbx
  - I convert an fbx, that contains 4 entities, 1,2,3,4 with names A,B,C,D
  - Overrides are created for all 4 entities
  - I drop a new version of the fbx and somehow indicate that I want to replace/merge
  - It creates 4 new entities 5,6,7,8 with names A,B,C,E
  - The editor matches A,B,C and overwrites enties 1,2,3 with the data in 5,6,7
  - The editor adds entity 8 (E) to the project and discards 5,6,7
  - An override is created for 8 (E)
  - 4 (D) has no more links and is removed, either explicitly or by "the broom"
  - The overrides still point to 1,2,3

